# Requirements Traceability Matrix

## Story: 5.1 - Pipeline Orchestrator Decomposition

### Coverage Summary

- Total Requirements: 4
- Fully Covered: 4 (100%)
- Partially Covered: 0 (0%)
- Not Covered: 0 (0%)

### Requirement Mappings

#### AC1: Extract helper functions/classes for each pipeline phase, keeping `run_pipeline()` as a thin coordinator.
**Coverage: FULL**
- `tests/unit/fancyrag/kg/test_phases.py::test_ingest_source_with_semantic_enrichment`
  - Given: Stubbed driver, OpenAI clients, and semantic enrichment hooks around `ingest_source`.
  - When: The helper processes a source with semantic enrichment enabled.
  - Then: Artifacts capture chunk metadata, QA rollups, and semantic stats without requiring global state, proving the phase-level helper paths execute independently.
- `tests/unit/fancyrag/kg/test_pipeline.py::test_run_pipeline_writes_log`
  - Given: `run_pipeline` is invoked with dependency injection stubs for driver, clients, and executors.
  - When: The coordinator is executed end-to-end.
  - Then: The pipeline delegates to helpers and produces a sanitized run log, demonstrating orchestration is thin and relies on extracted helpers.

#### AC2: Helpers accept explicit parameters (no direct `os.environ` access) and return typed results.
**Coverage: FULL**
- `tests/unit/fancyrag/kg/test_phases.py::test_build_clients_invokes_factories`
  - Given: Factory callables are injected into `build_clients`.
  - When: The helper builds the client bundle.
  - Then: All dependencies flow through explicit parameters, confirming dependency injection works for the client helper.
- `tests/unit/fancyrag/kg/test_phases.py::test_helpers_do_not_touch_environment`
  - Given: Environment access is restricted to forbid sensitive keys.
  - When: The helper suite executes end-to-end (settings, discovery, ingestion, QA).
  - Then: Helpers complete without touching hidden globals, proving explicit parameter flow across phases.

#### AC3: Update unit tests for each helper and extend integration smoke coverage to verify behaviour parity.
**Coverage: FULL**
- `tests/unit/fancyrag/kg/test_phases.py::test_ingest_source_without_semantic`, `::test_perform_qa_success_no_fallback`, and related cases
  - Given: Each helper is exercised with focused stubs.
  - When: Helpers run under different semantic and QA scenarios.
  - Then: They return well-typed dataclasses, covering the helper surface.
- `tests/integration/local_stack/test_minimal_path_smoke.py::test_minimal_path_smoke`
  - Given: The Docker stack and CLI scripts are orchestrated end-to-end.
  - When: The minimal path executes the rebuilt pipeline.
  - Then: Behaviour parity is verified against the previous orchestration.

#### AC4: Document the new call graph in `docs/architecture/projects/fancyrag-kg-build-refactor.md` and reference extracted functions.
**Coverage: FULL**
- `tests/unit/docs/architecture/test_helper_references.py::test_architecture_doc_lists_pipeline_helpers`
  - Given: Pipeline imports are parsed for helper functions.
  - When: The architecture shard is inspected.
  - Then: Test fails if a helper name is missing, guaranteeing documentation stays aligned with the helper surface.

### Critical Gaps

- None â€” helper coverage and documentation lint now enforce AC2 and AC4.

### Test Design Recommendations

1. Maintain the helper environment guard test as part of CI to catch regressions when new helpers are introduced.
2. Continue running the architecture lint test whenever helper imports change to prevent documentation drift.
3. Optionally extend the integration smoke to assert helper dataclasses serialise cleanly for downstream tooling.

### Risk Assessment

- **High Risk:** None
- **Medium Risk:** None
- **Low Risk:** Documentation drift mitigated by automated lint; integration parity maintained.

Trace matrix: docs/qa/assessments/5.1-trace-20251006.md
