# Requirements Traceability Matrix

## Story: 5.3 - Automate Stack Lifecycle Workflows

### Coverage Summary

- Total Requirements: 5
- Fully Covered: 5 (100%)
- Partially Covered: 0 (0%)
- Not Covered: 0 (0%)

### Requirement Mappings

#### AC1: Provide a consolidated automation entry point that chains bootstrap, ingestion, export, evaluation, and teardown with structured logging.
**Coverage: FULL**
- Unit Test: `tests/unit/fancyrag/cli/test_service_workflow.py::test_service_run_invokes_stages_in_order`
  - Given: A stubbed `ServiceWorkflow` with fake subprocess handlers and cached settings.
  - When: `workflow.run()` executes with default overrides.
  - Then: The stage list is `bootstrap → create_vector_index → ingest → export → evaluation → teardown`, proving the automation orchestrates all phases.
- Unit Test: `tests/unit/fancyrag/cli/test_service_workflow.py::test_service_run_emits_stage_logs`
  - Given: The workflow writing artifacts into a temporary run directory.
  - When: The run completes.
  - Then: The summary exposes structured artifacts (`vector_index_log`, `kg_log`, `export_log`, `docs_check`, `qa_dir`), validating logging and stage evidence.
- Integration Test: `tests/integration/local_stack/test_minimal_path_smoke.py::test_minimal_path_smoke`
  - Given: Docker stack assets, automation script, and smoke dataset available.
  - When: `make service-run` invokes the entry point end-to-end.
  - Then: The generated `service_run.json` records stage success and artifacts, asserting the consolidated workflow runs in a real environment.

#### AC2: Implement guarded rollback/cleanup commands that restore Docker services, Neo4j/Qdrant data, and artifacts on failure or cancellation.
**Coverage: FULL**
- Unit Test: `tests/unit/fancyrag/cli/test_service_workflow.py::test_service_rollback_invokes_cleanup`
  - Given: Stubbed Neo4j, Qdrant, and check-script hooks.
  - When: `ServiceWorkflow.rollback()` executes with `destroy_volumes=True` and a captured `kg_build.json` payload.
  - Then: `rollback_ingest` receives the decoded QA sources, Qdrant deletion runs for the configured collection, and the teardown script is invoked with `--destroy-volumes`, proving guarded cleanup restores the stack.
- Integration Test: `tests/integration/local_stack/test_minimal_path_smoke.py::test_minimal_path_smoke`
  - Given: The automation entry point finishes executing.
  - When: The fixture enters the `finally` block.
  - Then: `make service-reset` (rollback + destroy volumes) is executed, validating the command wiring end to end.

#### AC3: Support configurable presets (dataset path/profile/telemetry) while defaulting to the smoke dataset.
**Coverage: FULL**
- Unit Test: `tests/unit/config/test_fancyrag_settings.py::test_service_settings_defaults`
  - Given: Typed settings loaded from environment defaults.
  - When: `FancyRAGSettings.load(refresh=True)` hydrates the service section.
  - Then: The service preset defaults to `smoke` with the smoke dataset path, matching baseline expectations.
- Unit Test: `tests/unit/config/test_fancyrag_settings.py::test_service_settings_env_overrides`
  - Given: Environment overrides for preset, dataset directory, telemetry, vector index, and collection.
  - When: Settings reload with `refresh=True`.
  - Then: Overrides are honored, ensuring automation accepts configurable presets.
- Unit Test: `tests/unit/fancyrag/cli/test_service_workflow.py::test_service_run_custom_dataset_path`
  - Given: A custom dataset file created at runtime.
  - When: `workflow.run()` executes with `dataset_path` override.
  - Then: The ingestion command receives the absolute path and exports the relative dataset path into the environment, validating override plumbing.
- Unit Test: `tests/unit/fancyrag/cli/test_service_workflow.py::test_service_run_applies_preset_env`
  - Given: The workflow run with default settings.
  - When: Subprocess calls are inspected.
  - Then: Pipeline env vars (`FANCYRAG_PRESET`, `DATASET_PATH`, `FANCYRAG_TELEMETRY`) propagate from typed settings, confirming preset wiring.

#### AC4: Document the automation workflow and update onboarding references to the new command surface.
**Coverage: FULL**
- Unit Test: `tests/unit/scripts/test_check_docs.py::test_main_passes_when_all_tokens_present`
  - Given: Temporary documentation containing the required automation tokens (including `make service-run`, `make service-rollback`, `make service-reset`).
  - When: `scripts.check_docs.main()` runs against the fixture.
  - Then: The lint passes, ensuring documentation includes the consolidated command surface.
- Integration Test: `tests/integration/local_stack/test_minimal_path_smoke.py::test_minimal_path_smoke`
  - Given: The automation workflow completes.
  - When: The generated `service_run.json` is inspected.
  - Then: The `docs_check` artifact is present, demonstrating the documentation lint guard executed successfully against the real docs set.

#### AC5: Extend integration smoke coverage to execute the automation entry point end-to-end.
**Coverage: FULL**
- Integration Test: `tests/integration/local_stack/test_minimal_path_smoke.py::test_minimal_path_smoke`
  - Given: Docker, scripts, and environment variables provisioned.
  - When: The test triggers `make service-run` and inspects generated artifacts.
  - Then: Service summaries, KG logs, QA outputs, and export logs exist with success status, proving the smoke test now reaches the automation entry point.

### Critical Gaps

- None — rollback automation and failure sanitisation now have automated coverage.

### Test Design Recommendations

- Continue monitoring the integration smoke (`tests/integration/local_stack/test_minimal_path_smoke.py`) for dataset growth to ensure teardown timings stay within baseline thresholds.

### Risk Assessment

- **Residual Risk:** Low — Guarded rollback paths and teardown volume purges are now exercised by regression tests.

Trace matrix: docs/qa/assessments/5.3-trace-20251007.md
