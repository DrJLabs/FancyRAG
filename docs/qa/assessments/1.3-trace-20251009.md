# Requirements Traceability Matrix

## Story: 1.3 - Containerized Deployment

### Coverage Summary

- Total Requirements: 3
- Fully Covered: 1 (33%)
- Partially Covered: 1 (33%)
- Not Covered: 1 (33%)

### Requirement Mappings

#### AC1: Dockerfile builds Python image with FastMCP and project sources.

**Coverage: PARTIAL**

Given-When-Then Mappings:

- **Integration Test**: `tests/smoke/test_stack.py::test_compose_smoke_stack`
  - Given: The Docker image is built via `docker compose build mcp` inside the smoke stack with the production Dockerfile and environment variables sourced from `.env.local`/defaults.
  - When: Compose launches the `neo4j`, `embedding-stub`, and `mcp` services and the smoke test container invokes the FastMCP entrypoint.
  - Then: `/mcp/health` responds successfully and the `search` tool returns a non-empty payload, demonstrating the container boots with project sources and dependencies installed by `uv sync --frozen`.
  - Coverage: partial — the smoke test proves the image builds and boots, but there is no automated check that `.dockerignore` excludes secrets or that CI performs a secret scan/digest capture.

#### AC2: `docker-compose.yml` includes `mcp` service on `rag-net` with port 8080.

**Coverage: NONE**

No automated test exercises the production `docker-compose.yml`. The smoke stack uses `docker-compose.smoke.yml`, so schema drift (missing `rag-net`, published port, or `depends_on` wiring) would not be caught. A static validation step (e.g., `docker compose -f docker-compose.yml config` with assertions or a unit test parsing the YAML) is absent.

#### AC3: `docker compose up -d neo4j mcp` starts successfully and logs confirm server readiness.

**Coverage: FULL**

Given-When-Then Mappings:

- **Integration Test**: `tests/smoke/test_stack.py::test_compose_smoke_stack`
  - Given: The smoke Compose stack starts Neo4j, the embedding stub, and the FastMCP container with health checks enabled.
  - When: The smoke pytest waits for `/mcp/health`, seeds Neo4j with sample data, and invokes the MCP `search` tool via the internal network.
  - Then: The request returns at least one result, confirming the stack reaches healthy state and serves hybrid queries while emitting readiness logs.

### Critical Gaps

1. **AC1 secret hygiene** — No automated secret scan of the Docker image or lint ensuring `.dockerignore` continues to exclude `.env*`; a regression could leak credentials. Add CI job running `trivy --scanners secret` or similar.
2. **AC2 Compose drift** — Lack of validation for the canonical `docker-compose.yml`; introduce a test that parses the YAML to assert `services.mcp` exposes port 8080 and joins `rag-net`, or run `docker compose config --quiet` as part of CI.

### Test Design Recommendations

1. Create a lightweight unit/static test that loads `docker-compose.yml` and asserts required keys (`services.mcp.build`, `depends_on.neo4j`, `networks` membership, published port) to give deterministic feedback without Docker runtime.
2. Extend the smoke workflow to execute `docker compose -f docker-compose.yml up --wait neo4j mcp` at least once (with host port publishing disabled via overrides) so the production manifest stays verified.
3. Add a CI stage that builds the image, captures the digest, and runs a secret scan plus `.dockerignore` lint to close BUILD-001/SEC-002 risks.

### Risk Assessment

- **High Risk**: AC2 remains unvalidated; compose drift would silently break deployments. Mitigation: add schema lint/unit test in CI.
- **Medium Risk**: Secret scanning for the Docker image is manual; automation would reduce SEC-002 exposure.
- **Low Risk**: AC3 validated end-to-end; residual risk limited to performance regressions already guarded by smoke latency assertions.

Trace references: docs/qa/assessments/1.3-trace-20251009.md
